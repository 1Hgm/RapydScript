#!/usr/bin/env node
// vim:ft=javascript:ts=4:et

"use strict";

var start_time = new Date().getTime();
var RapydScript = require("../tools/compiler");
var sys = RapydScript.sys
var argv = require('../tools/cli').argv;
var path = require('path');
var fs = require('fs');

// configure settings for the output
var OUTPUT_OPTIONS = {
    beautify: argv.beautify,
    private_scope: !argv.bare,
    auto_bind: argv.auto_bind,
    omit_baselib: argv.omit_baselib
};

var base_path = path.normalize(path.join(path.dirname(module.filename), ".."));
var src_path = path.join(base_path, 'src');
var lib_path = path.join(base_path, 'lib');

function parse_file(code, file, toplevel) {
    return RapydScript.parse(code, {
        filename: file,
        toplevel: toplevel,
        readfile: fs.readFileSync,
        basedir: path.dirname(file),
        auto_bind: argv.auto_bind,
        libdir: path.join(src_path, 'lib'),
    });
}

function parse_baselib(beautify) {
    try {
        var baselibPath = path.join(src_path, 'baselib.pyj');
        var baselibAst = RapydScript.parse(fs.readFileSync(baselibPath, "utf-8"), {
            readfile: fs.readFileSync,
        });
    } catch(e) {
        if (e.code == "ENOENT") {
            throw "Failed to locate baselib module.";
        }
        else {
            throw e;
        }
    }
    var outputStream = RapydScript.OutputStream({
        private_scope: false,
        beautify: (beautify !== undefined) ? beautify : OUTPUT_OPTIONS.beautify,
        write_name: false,
        omit_baselib: true,  // We are generating baselib here, cannot depend on it
    });
    baselibAst.print(outputStream);
    OUTPUT_OPTIONS.baselib = eval(outputStream.toString());

}

function write_output(output) {
    if (argv.output) {
        fs.writeFileSync(argv.output, output, "utf8");
    } else {
        sys.print(output);
    }
}

function generate_baselib() {
    var output = '';
    Object.keys(OUTPUT_OPTIONS.baselib).forEach(function(key) {
        output += String(OUTPUT_OPTIONS.baselib[key]) + '\n\n';
    });
    return output;
}

function compile_self() {  // {{{
    OUTPUT_OPTIONS.beautify = true;
    OUTPUT_OPTIONS.private_scope = false;
    OUTPUT_OPTIONS.omit_baselib = true;
    OUTPUT_OPTIONS.write_name = false;


    function timed(name, cont) {
        var t1 = new Date().getTime();
        sys.print('Compiling', name, '...');
        var ret = cont();
        sys.print('Compiled in', (new Date().getTime() - t1)/1000, 'seconds\n');
        return ret;
    }

    var saved_hashes = {}, hashes = {}, compiled = {}, crypto = require('crypto');
    var compiler_changed = false, sha1sum;
    var signatures = path.join(lib_path, 'signatures.json');
    try {
        saved_hashes = JSON.parse(fs.readFileSync(signatures, 'utf-8'));
    } catch (e) {
        if (e.code != 'ENOENT') throw (e);
    }

    sha1sum = crypto.createHash('sha1');
    RapydScript.FILES.concat([module.filename, path.join(base_path, 'tools', 'compiler.js')]).forEach(function (fpath) {
        sha1sum.update(fs.readFileSync(fpath));
    });
    hashes['#compiler#'] = sha1sum.digest('hex');
    RapydScript.FILENAMES.forEach(function (fname) {
        var src = path.join(src_path, fname + '.pyj');
        var h = crypto.createHash('sha1');
        h.update(fs.readFileSync(src))
        hashes[fname] = h.digest('hex')
    });
    compiler_changed = (hashes['#compiler#'] != saved_hashes['#compiler#']) ? true : false;
    function changed(name) {
        return compiler_changed || hashes[name] != saved_hashes[name];
    }

    parse_baselib();
    var compiled = {};
    if (changed('baselib')) compiled['baselib'] = timed('baselib', generate_baselib);
    RapydScript.FILENAMES.slice(1).forEach(function (fname) {
        if (changed(fname)) {
            var src = path.join(src_path, fname + '.pyj');
            timed(fname, function() {
                var toplevel = parse_file(fs.readFileSync(src, "utf-8"), src);
                var output = RapydScript.OutputStream(OUTPUT_OPTIONS);
                toplevel.print(output);
                compiled[fname] = output.get();
            });
        }
    });
    sys.print('Compiling RapydScript succeeded (', (new Date().getTime() - start_time)/1000, 'seconds ), writing output...');
    Object.keys(compiled).forEach(function (fname) {
        argv.output = path.join(lib_path, fname + '.js');
        write_output(compiled[fname]);
    });
    fs.writeFileSync(signatures, JSON.stringify(hashes, null, 4));
}  // }}}

var files = argv.files.slice();

// Output the baselib as bare functions for use of the compiler itself
if (argv.self) {
    if (files.length > 0) {
        sys.error("WARN: Ignoring input files since --self was passed");
    }
    compile_self();
    process.exit(0);
}

var running_repl = false;
if (files.length == 0) {
    if (process.stdin.isTTY) {
        require('../tools/repl').repl(RapydScript, fs.readFileSync(path.join(lib_path, 'baselib.js'), 'utf-8'));
        running_repl = true;
    } else {
        files = [ "-" ];
    }
}

// Tests {{{
if (argv.test || argv.test === '') {
    // run all tests and exit
    var assert = require("assert");
    var os = require('os');
    var all_ok = true;
    var vm = require('vm');
    var test_dir = path.join(base_path, 'test');

    OUTPUT_OPTIONS.beautify = true;
    parse_baselib();

    if (argv.test)
        var files = [argv.test + '.pyj'];
    else
        var files = fs.readdirSync(test_dir).filter(function(name){
            return /^[^_].*\.pyj$/.test(name);
        });
    files.forEach(function(file){
        var ast;
        var filepath = path.join(test_dir, file);
        try {
            ast = RapydScript.parse(fs.readFileSync(filepath, "utf-8"), {
                filename: file,
                toplevel: ast,
                readfile: fs.readFileSync,
                basedir: test_dir,
                libdir: path.join(src_path, 'lib'),
            });
        } catch(ex) {
//            if (ex instanceof RapydScript.JS_Parse_Error) {
//               sys.print("Error parsing test file: " + file);
//            }
            sys.print(file + ":\t" + ex + "\n");
            return;
        }
        // generate output
        var output = RapydScript.OutputStream({
            baselib: OUTPUT_OPTIONS.baselib,
            beautify: true
        });
        ast.print(output);

        // test that output performs correct JS operations
        var testcontent = "exports.run = function(){" + output.toString() + "};";
        var jsfile = path.join(os.tmpdir(), file + '.js');
        var code = output.toString();
        fs.writeFileSync(jsfile, code);
        try {
            vm.runInNewContext(code, {'assert':require('assert'), 'RapydScript':RapydScript, 'console':console}, {'filename':jsfile});
			var ok = true;
            fs.unlinkSync(jsfile);
        } catch (e) {
            if (e.stack) {
                sys.print(file + ":\t" + e.stack + "\n\n");
            } else {
                sys.print(file + ":\t" + e + "\n\n");
            }
        }
		if (ok) sys.print(file + ":\ttest completed successfully\n");
        else { all_ok = false; sys.print(file + ":\ttest failed\n"); }
    });
    if (!all_ok) sys.print('There were some test failures!!');
    process.exit((all_ok) ? 0 : 1);
} // }}}

if (argv.comments) {
    if (/^\//.test(argv.comments)) {
        OUTPUT_OPTIONS.comments = new Function("return(" + argv.comments + ")")();
    } else if (argv.comments == "all") {
        OUTPUT_OPTIONS.comments = true;
    } else {
        OUTPUT_OPTIONS.comments = function(node, comment) {
            var text = comment.value;
            var type = comment.type;
            if (type == "comment2") {
                // multiline comment
                return /@preserve|@license|@cc_on/i.test(text);
            }
        }
    }
}

var TOPLEVEL, STATS = {};
var num_of_files = files.length;

function compile_single_file(err, code) {
    if (err) {
        sys.error("ERROR: can't read file: " + file);
        process.exit(1);
    }
    time_it("parse", function(){
        TOPLEVEL = parse_file(code, files[0], TOPLEVEL);
    });

    try {
        var output = RapydScript.OutputStream(OUTPUT_OPTIONS);
    } catch(ex) {
        if (ex instanceof RapydScript.DefaultsError) {
            sys.error(ex.msg);
            sys.error("Supported options:");
            sys.error(sys.inspect(ex.defs));
            process.exit(1);
        }
        throw ex;
    }

    time_it("generate", function(){
        TOPLEVEL.print(output);
    });

    output = output.get();

    write_output(output);

    files = files.slice(1);
    if (files.length) {
        setImmediate(read_whole_file, files[0], compile_single_file);
        return;
    }
    if (argv.stats) {
        sys.error(RapydScript.string_template("Timing information (compressed {count} files):", {
            count: num_of_files
        }));
        for (var i in STATS) if (STATS.hasOwnProperty(i)) {
            sys.error(RapydScript.string_template("- {name}: {time}s", {
                name: i,
                time: (STATS[i] / 1000).toFixed(3)
            }));
        }
    }
}

if (!running_repl) {
    parse_baselib();
    if (files.filter(function(el){ return el == "-" }).length > 1) {
        sys.error("ERROR: Can read a single file from STDIN (two or more dashes specified)");
        process.exit(1);
    }

    setImmediate(read_whole_file, files[0], compile_single_file);
}

/* -----[ functions ]----- {{{ */ 

function read_whole_file(filename, cb) {
    if (filename == "-") {
        var chunks = [];
        process.stdin.setEncoding('utf-8');
        process.stdin.on('data', function (chunk) {
            chunks.push(chunk);
        }).on('end', function () {
            cb(null, chunks.join(""));
        });
        process.openStdin();
    } else {
        fs.readFile(filename, "utf-8", cb);
    }
}

function time_it(name, cont) {
    var t1 = new Date().getTime();
    var ret = cont();
    if (argv.stats) {
        var spent = new Date().getTime() - t1;
        if (STATS[name]) STATS[name] += spent;
        else STATS[name] = spent;
    }
    return ret;
}
// }}}
