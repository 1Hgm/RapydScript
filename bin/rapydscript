#!/usr/bin/env node
// vim:ft=javascript:ts=4:et

"use strict";

var RapydScript = require("../tools/node");
var sys = require("util");
if (typeof console == 'object' && typeof console.error == 'function') {
	sys.print = console.log;
	sys.puts = console.log;
	sys.error = console.error;
	sys.debug = console.error;
}
var optimist = require("optimist");
var fs = require("fs");
var async = require("async");
var path = require("path");
var ARGS = optimist
    .usage("$0 input1.js [input2.js ...] [options]\n\
Use a single dash to read input from the standard input.\
\n\n\
")
    .describe("o", "Output file (default STDOUT).")
    .describe("b", "Remove the module wrapper that prevents RapydScript \
scope from bleeding into other JavaScript logic.")
    .describe("i", "Automatically bind function methods to functions themselves \
instead of using @bound decorator [experimental].")
    .describe("p", "Prettify output/specify output options.")
    .describe("m", "Omit baselib functions (use this if you have a different way of ensuring they're imported, such as including baselib.js).")
    .describe("t", "Run RapydScript tests")
    .describe("w", "When testing, run only the specified test file, for e.g., -w classes")
    .describe('N', 'Do not set __name__ for the main module. Used internally when compiling rapydscript itself')
    .describe('self', 'Used internally to compile the compiler itself')

    .describe("comments", "Preserve copyright comments in the output. \
By default this works like Google Closure, keeping JSDoc-style comments that contain \"@license\" or \"@preserve\". \
You can optionally pass one of the following arguments to this flag:\n\
- \"all\" to keep all comments\n\
- a valid JS regexp (needs to start with a slash) to keep only comments that match.\n\
\
Note that currently not *all* comments can be kept when compression is on, \
because of dead code removal or cascading statements into sequences.")

    .describe("stats", "Display operations run time on STDERR.")
//    .describe("self", "Build itself (RapydScript2) as a library (implies --wrap=RapydScript --export-all)")
//    .describe("wrap", "Embed everything in a big function, making the “exports” and “global” variables available. \
//You need to pass an argument to this option to specify the name that your module will take when included in, say, a browser.")
//    .describe("export-all", "Only used when --wrap, this tells RapydScript to add code to automatically export all globals.")
    .describe("v", "Verbose")
    .describe("V", "Print version number and exit.")

    .alias("o", "output")
    .alias("b", "bare")
    .alias("v", "verbose")
    .alias("i", "auto-bind")
    .alias("p", "prettify")
    .alias("m", "omit-baselib")
    .alias("V", "version")
    .alias("t", "test")

    .string("comments")
    .string("wrap")
    .boolean("p")
    .boolean("v")
    .boolean("stats")
    .boolean("V")
//    .boolean("export-all")
   .boolean("self")
   .boolean('N')
   .boolean('t')
   .boolean('m')

    .wrap(80)

    .argv
;

normalize(ARGS);

if (ARGS.version || ARGS.V) {
    var json = require("../package.json");
    sys.puts(json.name + ' ' + json.version);
    process.exit(0);
}

if (ARGS.ast_help) {
    var desc = RapydScript.describe_ast();
    sys.puts(typeof desc == "string" ? desc : JSON.stringify(desc, null, 2));
    process.exit(0);
}

if (ARGS.h || ARGS.help) {
    sys.puts(optimist.help());
    process.exit(0);
}

// configure settings for the output
var BEAUTIFY = getOptions("p", true);
var NO_MODULE_WRAPPER = getOptions("b", false);
var AUTO_BIND = getOptions("i", false);
var OMIT_BASELIB = getOptions("m", false);

var OUTPUT_OPTIONS = {
    beautify: BEAUTIFY ? true : false,
    private_scope: NO_MODULE_WRAPPER ? false : true,
    auto_bind: AUTO_BIND ? true : false,
    omit_baselib: OMIT_BASELIB ? true : false,
    write_name: !getOptions('N', true),
};

var src_path = path.normalize(path.join(path.dirname(module.filename), "..", "src"));
var lib_path = path.normalize(path.join(path.dirname(module.filename), "..", "lib"));

function parse_file(code, file, toplevel) {
    return RapydScript.parse(code, {
        filename: file,
        toplevel: toplevel,
        readfile: fs.readFileSync,
        basedir: path.dirname(file),
        auto_bind: AUTO_BIND ? true : false,
        libdir: path.join(src_path, 'lib'),
    });
}

function parse_baselib() {
    try {
        var baselibPath = path.join(src_path, 'baselib.pyj');
        var baselibAst = RapydScript.parse(fs.readFileSync(baselibPath, "utf-8"), {
            readfile: fs.readFileSync,
        });
    } catch(e) {
        if (e.code == "ENOENT") {
            throw "Failed to locate baselib module.";
        }
        else {
            throw e;
        }
    }
    var outputStream = RapydScript.OutputStream({
        private_scope: false,
        beautify: BEAUTIFY ? true : false,
        write_name: false,
        omit_baselib: true,  // We are generating baselib here, cannot depend on it
    });
    baselibAst.print(outputStream);
    OUTPUT_OPTIONS.baselib = eval(outputStream.toString());

}

function write_output(output) {
    if (ARGS.o) {
        fs.writeFileSync(ARGS.o, output, "utf8");
    } else {
        sys.print(output);
    }
}

function generate_baselib() {
    var output = '';
    Object.keys(OUTPUT_OPTIONS.baselib).forEach(function(key) {
        output += String(OUTPUT_OPTIONS.baselib[key]) + '\n\n';
    });
    return output;
}

function compile_self() {
    OUTPUT_OPTIONS.beautify = true;
    OUTPUT_OPTIONS.private_scope = false;
    OUTPUT_OPTIONS.omit_baselib = true;
    OUTPUT_OPTIONS.write_name = false;
    BEAUTIFY = true;

    var start_time = new Date().getTime();

    function timed(name, cont) {
        var t1 = new Date().getTime();
        sys.print('Compiling', name, '...');
        var ret = cont();
        sys.print('Compiled in', (new Date().getTime() - t1)/1000, 'seconds\n');
        return ret;
    }
    parse_baselib();
    ARGS.o = path.join(lib_path, "baselib.js");
    var compiled = {'baselib': timed('baselib', generate_baselib)}
    RapydScript.FILENAMES.slice(1).forEach(function (fname) {
        var src = path.join(src_path, fname + '.pyj');
        timed(fname, function() {
            var toplevel = parse_file(fs.readFileSync(src, "utf-8"), src);
            var output = RapydScript.OutputStream(OUTPUT_OPTIONS);
            toplevel.print(output);
            compiled[fname] = output.get();
        });
    });
    sys.print('Compiling RapydScript succeeded (', (new Date().getTime() - start_time)/1000, 'seconds ), writing output...');
    Object.keys(compiled).forEach(function (fname) {
        ARGS.o = path.join(lib_path, fname + '.js');
        write_output(compiled[fname]);
    });
}

var files = ARGS._.slice();

// Output the baselib as bare functions for use of the compiler itself
if (ARGS.self) {
    if (files.length > 0) {
        sys.error("WARN: Ignoring input files since --self was passed");
    }
    compile_self();
    process.exit(0);
}

// generate baselib with current settings
if (!OMIT_BASELIB || ARGS.t || !ARGS.test) {
    parse_baselib();
}


if (ARGS.t || ARGS.test) {
    // run all tests and exit
    var assert = require("assert");
    var os = require('os');
    var all_ok = true;
    var test_dir = path.normalize(
        path.join(
            path.dirname(module.filename),
            "../test"
        )
    );
    if (ARGS.w)
        var files = [ARGS.w + '.pyj'];
    else
        var files = fs.readdirSync(test_dir).filter(function(name){
            return /^[^_].*\.pyj$/.test(name);
        });
    files.forEach(function(file){
        var ast;
        var filepath = path.join(test_dir, file);
        try {
            ast = RapydScript.parse(fs.readFileSync(filepath, "utf-8"), {
                filename: file,
                toplevel: ast,
                readfile: fs.readFileSync,
                basedir: path.normalize(
                    path.join(
                        path.dirname(module.filename),
                        "../test"
                    )
                ),
                libdir: path.normalize(
                    path.join(
                        path.dirname(module.filename),
                        "../src/lib"
                    )
                )
            });
        } catch(ex) {
//            if (ex instanceof RapydScript.JS_Parse_Error) {
//               sys.print("Error parsing test file: " + file);
//            }
            sys.print(file + ":\t" + ex + "\n");
            return;
        }
        // generate output
        var output = RapydScript.OutputStream({
            baselib: OUTPUT_OPTIONS.baselib,
            beautify: true
        });
        ast.print(output);

        // test that output performs correct JS operations
        var testcontent = "exports.run = function(){assert = require('assert');" + output.toString() + "};";
        var jsfile = path.join(os.tmpdir(), file + '.js')
        fs.writeFileSync(jsfile, testcontent);
        var testcase = require(jsfile);
		var ok = false;
        try {
            testcase.run();
			ok = true;
            fs.unlinkSync(jsfile);
        } catch (e) {
            if (e.stack) {
                sys.print(file + ":\t" + e.stack + "\n\n");
            } else {
                sys.print(file + ":\t" + e + "\n\n");
            }
        }
		if (ok) sys.print(file + ":\ttest completed successfully\n");
        else { all_ok = false; sys.print(file + ":\ttest failed\n"); }
    });
    if (!all_ok) sys.print('There were some test failures!!');
    process.exit((all_ok) ? 0 : 1);
}

//if (BEAUTIFY);
//    RapydScript.merge(OUTPUT_OPTIONS, BEAUTIFY);

if (ARGS.comments) {
    if (/^\//.test(ARGS.comments)) {
        OUTPUT_OPTIONS.comments = new Function("return(" + ARGS.comments + ")")();
    } else if (ARGS.comments == "all") {
        OUTPUT_OPTIONS.comments = true;
    } else {
        OUTPUT_OPTIONS.comments = function(node, comment) {
            var text = comment.value;
            var type = comment.type;
            if (type == "comment2") {
                // multiline comment
                return /@preserve|@license|@cc_on/i.test(text);
            }
        }
    }
}

if (files.length == 0) {
    files = [ "-" ];
}

if (files.filter(function(el){ return el == "-" }).length > 1) {
    sys.error("ERROR: Can read a single file from STDIN (two or more dashes specified)");
    process.exit(1);
}

var STATS = {};
var TOPLEVEL = null;

try {
    var output = RapydScript.OutputStream(OUTPUT_OPTIONS);
} catch(ex) {
    if (ex instanceof RapydScript.DefaultsError) {
        sys.error(ex.msg);
        sys.error("Supported options:");
        sys.error(sys.inspect(ex.defs));
        process.exit(1);
    }
    throw ex;
}

async.eachLimit(files, 1, function (file, cb) {
    read_whole_file(file, function (err, code) {
        if (err) {
            sys.error("ERROR: can't read file: " + file);
            process.exit(1);
        }
//        if (ARGS.p != null) {
//            file = file.replace(/^\/+/, "").split(/\/+/).slice(ARGS.p).join("/");
//        }
        time_it("parse", function(){
            TOPLEVEL = parse_file(code, file, TOPLEVEL);
        });
        cb();
    });
}, function () {
    if (ARGS.wrap) {
        TOPLEVEL = TOPLEVEL.wrap_commonjs(ARGS.wrap, ARGS.export_all);
    }

    if (ARGS.enclose) {
        var arg_parameter_list = ARGS.enclose;

        if (!(arg_parameter_list instanceof Array)) {
            arg_parameter_list = [arg_parameter_list];
        }

        TOPLEVEL = TOPLEVEL.wrap_enclose(arg_parameter_list);
    }

    time_it("generate", function(){
        TOPLEVEL.print(output);
    });

    output = output.get();

    write_output(output);

    if (ARGS.stats) {
        sys.error(RapydScript.string_template("Timing information (compressed {count} files):", {
            count: files.length
        }));
        for (var i in STATS) if (STATS.hasOwnProperty(i)) {
            sys.error(RapydScript.string_template("- {name}: {time}s", {
                name: i,
                time: (STATS[i] / 1000).toFixed(3)
            }));
        }
    }
});

/* -----[ functions ]----- */

function normalize(o) {
    for (var i in o) if (o.hasOwnProperty(i) && /-/.test(i)) {
        o[i.replace(/-/g, "_")] = o[i];
        delete o[i];
    }
}

function getOptions(x, constants) {
    x = ARGS[x];
    if (!x) return null;
    var ret = {};
    if (x !== true) {
        var ast;
        try {
            ast = RapydScript.parse(x);
        } catch(ex) {
            if (ex instanceof RapydScript.JS_Parse_Error) {
                sys.error("Error parsing arguments in: " + x);
                process.exit(1);
            }
        }
        ast.walk(new RapydScript.TreeWalker(function(node){
            if (node instanceof RapydScript.AST_Toplevel) return; // descend
            if (node instanceof RapydScript.AST_SimpleStatement) return; // descend
            if (node instanceof RapydScript.AST_Seq) return; // descend
            if (node instanceof RapydScript.AST_Assign) {
                var name = node.left.print_to_string({ beautify: false }).replace(/-/g, "_");
                var value = node.right;
                if (constants)
                    value = new Function("return (" + value.print_to_string() + ")")();
                ret[name] = value;
                return true;    // no descend
            }
            sys.error(node.TYPE)
            sys.error("Error parsing arguments in: " + x);
            process.exit(1);
        }));
    }
    return ret;
}

function read_whole_file(filename, cb) {
    if (filename == "-") {
        var chunks = [];
        process.stdin.setEncoding('utf-8');
        process.stdin.on('data', function (chunk) {
            chunks.push(chunk);
        }).on('end', function () {
            cb(null, chunks.join(""));
        });
        process.openStdin();
    } else {
        fs.readFile(filename, "utf-8", cb);
    }
}

function time_it(name, cont) {
    var t1 = new Date().getTime();
    var ret = cont();
    if (ARGS.stats) {
        var spent = new Date().getTime() - t1;
        if (STATS[name]) STATS[name] += spent;
        else STATS[name] = spent;
    }
    return ret;
}
