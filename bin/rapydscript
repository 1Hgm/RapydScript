#!/usr/bin/env node
// vim:ft=javascript:ts=4:et

"use strict";

var start_time = new Date().getTime();
var RapydScript = require("../tools/compiler");
var sys = RapydScript.sys
var argv = require('../tools/cli').argv;
var path = require('path');
var fs = require('fs');

// configure settings for the output
var OUTPUT_OPTIONS = {
    beautify: argv.beautify,
    private_scope: !argv.bare,
    auto_bind: argv.auto_bind,
    omit_baselib: argv.omit_baselib
};

var base_path = path.normalize(path.join(path.dirname(module.filename), ".."));
var src_path = path.join(base_path, 'src');
var lib_path = path.join(base_path, 'lib');

function parse_file(code, file, toplevel) {
    return RapydScript.parse(code, {
        filename: file,
        toplevel: toplevel,
        readfile: fs.readFileSync,
        basedir: path.dirname(file),
        auto_bind: argv.auto_bind,
        libdir: path.join(src_path, 'lib'),
    });
}

function parse_baselib(beautify) {
    try {
        var baselibPath = path.join(src_path, 'baselib.pyj');
        var baselibAst = RapydScript.parse(fs.readFileSync(baselibPath, "utf-8"), {
            readfile: fs.readFileSync,
        });
    } catch(e) {
        if (e.code == "ENOENT") {
            throw "Failed to locate baselib module.";
        }
        else {
            throw e;
        }
    }
    var outputStream = RapydScript.OutputStream({
        private_scope: false,
        beautify: (beautify !== undefined) ? beautify : OUTPUT_OPTIONS.beautify,
        write_name: false,
        omit_baselib: true,  // We are generating baselib here, cannot depend on it
    });
    baselibAst.print(outputStream);
    OUTPUT_OPTIONS.baselib = eval(outputStream.toString());
    return OUTPUT_OPTIONS.baselib;
}

function write_output(output) {
    if (argv.output) {
        fs.writeFileSync(argv.output, output, "utf8");
    } else {
        sys.print(output);
    }
}

var files = argv.files.slice();

// Output the baselib as bare functions for use of the compiler itself
if (argv.self) {
    if (files.length > 0) {
        sys.error("WARN: Ignoring input files since --self was passed");
    }
    require('../tools/self')(RapydScript, parse_baselib(true), base_path, src_path, lib_path, start_time);
    process.exit(0);
}

if (argv.test) {
    require('../tools/test')(RapydScript, argv, base_path, src_path, parse_baselib(true));
} 

var running_repl = false;
if (files.length == 0) {
    if (process.stdin.isTTY) {
        require('../tools/repl').repl(RapydScript, fs.readFileSync(path.join(lib_path, 'baselib.js'), 'utf-8'));
        running_repl = true;
    } else {
        files = [ "-" ];
    }
}

if (argv.comments) {
    if (/^\//.test(argv.comments)) {
        OUTPUT_OPTIONS.comments = new Function("return(" + argv.comments + ")")();
    } else if (argv.comments == "all") {
        OUTPUT_OPTIONS.comments = true;
    } else {
        OUTPUT_OPTIONS.comments = function(node, comment) {
            var text = comment.value;
            var type = comment.type;
            if (type == "comment2") {
                // multiline comment
                return /@preserve|@license|@cc_on/i.test(text);
            }
        }
    }
}

var TOPLEVEL, STATS = {};
var num_of_files = files.length;

function compile_single_file(err, code) {
    if (err) {
        sys.error("ERROR: can't read file: " + file);
        process.exit(1);
    }
    time_it("parse", function(){
        TOPLEVEL = parse_file(code, files[0], TOPLEVEL);
    });

    try {
        var output = RapydScript.OutputStream(OUTPUT_OPTIONS);
    } catch(ex) {
        if (ex instanceof RapydScript.DefaultsError) {
            sys.error(ex.msg);
            sys.error("Supported options:");
            sys.error(sys.inspect(ex.defs));
            process.exit(1);
        }
        throw ex;
    }

    time_it("generate", function(){
        TOPLEVEL.print(output);
    });

    output = output.get();

    write_output(output);

    files = files.slice(1);
    if (files.length) {
        setImmediate(read_whole_file, files[0], compile_single_file);
        return;
    }
    if (argv.stats) {
        sys.error(RapydScript.string_template("Timing information (compressed {count} files):", {
            count: num_of_files
        }));
        for (var i in STATS) if (STATS.hasOwnProperty(i)) {
            sys.error(RapydScript.string_template("- {name}: {time}s", {
                name: i,
                time: (STATS[i] / 1000).toFixed(3)
            }));
        }
    }
}

if (!running_repl) {
    parse_baselib();
    if (files.filter(function(el){ return el == "-" }).length > 1) {
        sys.error("ERROR: Can read a single file from STDIN (two or more dashes specified)");
        process.exit(1);
    }

    setImmediate(read_whole_file, files[0], compile_single_file);
}

/* -----[ functions ]----- {{{ */ 

function read_whole_file(filename, cb) {
    if (filename == "-") {
        var chunks = [];
        process.stdin.setEncoding('utf-8');
        process.stdin.on('data', function (chunk) {
            chunks.push(chunk);
        }).on('end', function () {
            cb(null, chunks.join(""));
        });
        process.openStdin();
    } else {
        fs.readFile(filename, "utf-8", cb);
    }
}

function time_it(name, cont) {
    var t1 = new Date().getTime();
    var ret = cont();
    if (argv.stats) {
        var spent = new Date().getTime() - t1;
        if (STATS[name]) STATS[name] += spent;
        else STATS[name] = spent;
    }
    return ret;
}
// }}}
