"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under Apache 2.0 license:
    Copyright 2013 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

  RapydScript source code is originally based on UglifyJS2 (covered
  by BSD license). UglifyJS2 was written by Mihai Bazon
  <mihai.bazon@gmail.com>, who is its respective copyright holder.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

**********************************************************************
"""

"use strict"

NATIVE_CLASSES = {
    # javascript
    'Image': {},
    'RegExp': {},
    'Error': {},
    'Object': {
        static: [
            "assign",               # ES6
            "getOwnPropertyNames",
            "keys",
            "create",
            "defineProperty",
            "defineProperties",
            "getPrototypeOf",       # ES6
            "setPrototypeOf",       # ES6
        ]
    },
    'String': {
        static: [ "fromCharCode" ]
    },
    'Array': {
        static: [ "isArray", "from", "of" ]
    },
    'Number': {
        static: [ "isFinite", "isNaN" ]
    },
    'Function': {},
    'Date': {
        static: [ "UTC", "now", "parse" ]
    },
    'Boolean': {},
    'ArrayBuffer': {},
    'DataView': {},
    'Float32Array': {},
    'Float64Array': {},
    'Int16Array': {},
    'Int32Array': {},
    'Int8Array': {},
    'Uint16Array': {},
    'Uint32Array': {},
    'Uint8Array': {},
    'Uint8ClampedArray': {},
    'Map': {},      # ES6
    'WeakMap': {},  # ES6
    'Set': {},      # ES6
    'WeakSet': {},  # ES6

    # baselib
    "AssertionError": {},
    "IndexError": {},
    "KeyError": {},
    "TypeError": {},
    "ValueError": {},
}
COMMON_STATIC = [ "call", "apply", "bind", "toString" ]

CLASS_MAP = {}      # top-level classes will be populated into here

# detect common python stdlib methods - these will be auto-injected into the code when called
BASELIB = {}
STDLIB = [
    "abs",
    "bin",
    "cmp",
    "chr",
    "dir",
    "hex",
    "max",
    "min",
    "mixin",
    "print",
    "range",
    "reduce",
    "getattr",
    "setattr",
    "hasattr",

    # unique to RapydScript
    "eq",
    "bind",
    "rebind_all",

    # list operations
    "all",
    "any",
    "enumerate",
    "filter",
    "len",
    "map",
    "reversed",
    "sum",
    "zip",

    # errors
    "AssertionError",
    "IndexError",
    "KeyError",
    "TypeError",
    "ValueError",
]


# -----[ Parser (constants) ]-----
UNARY_PREFIX = makePredicate([
    "typeof",
    "void",
    "delete",
    "--",
    "++",
    "!",
    "~",
    "-",
    "+",
    "@"
])


ASSIGNMENT = makePredicate([ "=", "+=", "-=", "/=", "//=", "*=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=" ])

PRECEDENCE = def(a, ret):
    for i in range(a.length):
        b = a[i]
        for j in range(b.length):
            ret[b[j]] = i+1
    return ret
.call(this, [
    # lowest precedence
    [ "||" ],
    [ "&&" ],
    [ "|" ],
    [ "^" ],
    [ "&" ],
    [ "==", "===", "!=", "!==" ],
    [ "<", ">", "<=", ">=", "in", "instanceof" ],
    [ ">>", "<<", ">>>" ],
    [ "+", "-" ],
    [ "*", "/", "//", "%" ],
    [ "**" ]
    # highest precedence
], {})

STATEMENTS_WITH_LABELS = array_to_hash([ "for", "do", "while", "switch" ])

ATOMIC_START_TOKEN = array_to_hash([ "atom", "num", "string", "regexp", "name" ])

# per-module list of danger_zone flaga, if any
DANGER_ZONE = {}

# -----[ Parser ]-----
def parse($TEXT, options):
    options = defaults(options, {
        strict: False,          # whether to use strict JavaScript mode
        filename: None,         # name of the file being parsed
        auto_bind: False,       # whether auto-binding of methods to classes is enabled
        module_id: '__main__',  # The id of the module being parsed
        es6: False,             # whether we're using EcmaScript 6 mode
        toplevel: None,         # existing tree to append to, if None, new tree will be started
        import_dirs: [],        # List of directories to scan for imports
        classes: undefined      # Map of class names to AST_Class that are available in the global namespace (used by the REPL)
    })
    module_id = options.module_id

    # fallthrough order: --> relative basedir, user-specified import dirs, standard libdir
    import_dirs = options.import_dirs[:]
    if options.libdir: import_dirs.push(options.libdir)
    if options.basedir: import_dirs.unshift(options.basedir)

    IMPORTED = options.IMPORTED or {}
    IMPORTING = options.IMPORTING or {}
    IMPORTING[module_id] = True
    DANGER_ZONE[module_id] = {}

    S = {
        input: (typeof $TEXT == "string" ? tokenizer($TEXT, options.filename) : $TEXT),
        token: None,            # current token being scanned
        prev: None,             # previous token
        peeked: None,           # cached version of next token
        in_directives: True,    # per-scope directive, i.e. "use strict"
        in_loop: 0,             # number of loops we're currently nested inside of
        in_scope: [ {           # relevant context for given scope
            type: None,         # scope type
            vars: {},           # variables in this scope
            nonlocal: {},       # variables shared with outer scope
            classes: {}         # classes visible from this scope
        } ],
        labels: [],
        decorators: [],         # decorators we've most-recently seen, these get reset as soon as we see function body
    }

    if options.classes:
        for cname in options.classes:
            obj = options.classes[cname]
            S.in_scope[0].classes[cname] = {
                'static': obj.static,
                'bound': obj.bound
            }

    S.token = next()
    def is_(type, value):
        return is_token(S.token, type, value)

    def peek():
        return S.peeked or (S.peeked = S.input())

    def next():
        S.prev = S.token
        if S.peeked:
            S.token = S.peeked
            S.peeked = None
        else:
            S.token = S.input()

        S.in_directives = S.in_directives and (S.token.type == "string" or is_("punc", ";"))
        return S.token

    def prev():
        return S.prev

    def croak(msg, line, col, pos, is_eof):
        # note: undefined means nothing was passed in, None/null means a null value was passed in
        ctx = S.input.context()
        js_error(msg, ctx.filename, (line != undefined ? line : ctx.tokline),
                 (col != undefined ? col : ctx.tokcol), (pos != undefined ? pos : ctx.tokpos), is_eof)

    def token_error(token, msg):
        is_eof = (token.type == 'eof') ? true : false
        croak(msg, token.line, token.col, undefined, is_eof)

    def unexpected(token):
        if token == undefined:
            token = S.token
        token_error(token, "Unexpected token: " + token.type + " «" + token.value + "»")

    def expect_token(type, val):
        if is_(type, val):
            return next()
        token_error(S.token, "Unexpected token " + S.token.type + " «" + S.token.value + "»" +
                    ", expected " + type + " «" + val + "»")

    def expect(punc):
        return expect_token("punc", punc)

    def can_insert_semicolon():
        return not options.strict and (S.token.nlb or is_("eof") or is_("punc", "}"))

    def semicolon():
        if is_("punc", ";"):
            next()
            S.token.nlb = True

    def parenthesised():
        expect("(")
        exp = expression(True)
        expect(")")
        return exp

    def embed_tokens(parser):
        return def():
            start = S.token
            expr = parser()
            if expr == undefined:
                unexpected()
            end = prev()
            expr.start = start
            expr.end = end
            return expr

    def is_nested_comparison(stmt):
        """
        Check if the statement is a nested comparison
        """
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True,
            "===": True,
            "!==": True
        }
        if isinstance(stmt, AST_Binary) and stmt.operator in comparators \
                and isinstance(stmt.left, AST_Binary) and stmt.left.operator in comparators:
            return True
        else:
            return False

    def scan_for_top_level_callables(body):
        ans = []
        # Get the named functions and classes
        if Array.isArray(body):
            for name in dir(body):
                obj = body[name]
                if isinstance(obj, AST_Function) or isinstance(obj, AST_Class):
                    if obj.name:
                        ans.push(obj.name)
                    else:
                        token_error(obj.start, "Top-level functions must have names")
                else:
                    # skip inner scopes
                    if isinstance(obj, AST_Scope):
                        continue
                    for x in ['body', 'alternative']:
                        opt = obj[x]
                        if opt:
                            ans = ans.concat(scan_for_top_level_callables(opt))

                        if isinstance(opt, AST_Assign) and not (isinstance(opt.right, AST_Scope)):
                            ans = ans.concat(scan_for_top_level_callables(opt.right))
        elif body.body:
            # recursive descent into wrapper statements that contain body blocks
            ans = ans.concat(scan_for_top_level_callables(body.body))
            if body.alternative:
                ans = ans.concat(scan_for_top_level_callables(body.alternative))

        return ans


    statement = embed_tokens(def():
        if is_("operator", "/") or is_("operator", "/="):
            S.peeked = None
            S.token = S.input(S.token.value.substr(1))

        tmp_ = S.token.type
        if tmp_ == "string":
            dir = S.in_directives
            stat = simple_statement()
            # XXXv2: decide how to fix directives
            if dir and isinstance(stat.body, AST_String) and not is_("punc", ","):
                return new AST_Directive({
                    value: stat.body.value
                })

            return stat
        elif tmp_ == "shebang":
            tmp_ = S.token.value
            next()
            return new AST_Directive({
                value: tmp_
            })
        elif tmp_ == "num" or tmp_ == "regexp" or tmp_ == "operator" or tmp_ == "atom":
            return simple_statement()
        elif tmp_ == "punc":
            tmp_ = S.token.value
            if tmp_ == ":":
                return new AST_BlockStatement({
                    start: S.token,
                    body: block_(),
                    end: prev()
                })
            elif tmp_ == "{" or tmp_ == "[" or tmp_ == "(":
                return simple_statement()
            elif tmp_ == ";":
                next()
                return new AST_EmptyStatement()
            else:
                unexpected()
        elif tmp_ == "name":
            return (is_token(peek(), "punc", ":") ? labeled_statement() : simple_statement())
        elif tmp_ == "keyword":
            tmp_ = S.token.value

            if ES6_KEYWORDS(tmp_) and not options.es6:
                token_error(prev(), "«" + tmp_ + "» keyword not supported with ES5-compatible output, use --ecmascript6 compilation flag")

            next()
            if tmp_ == "break":
                return break_cont(AST_Break)
            elif tmp_ == "continue":
                return break_cont(AST_Continue)
            elif tmp_ == "debugger":
                semicolon()
                return new AST_Debugger()
            elif tmp_ == "do":
                return new AST_Do({
                    body: in_loop(statement),
                    condition: def():
                        expect(".")
                        expect_token("keyword", "while")
                        tmp = expression(True)
                        semicolon()
                        return tmp
                    .call(this)
                })
            elif tmp_ == "while":
                return new AST_While({
                    condition: expression(True),
                    body: in_loop(statement)
                })
            elif tmp_ == "for":
                if is_("name", "JS"):
                    return for_js()
                return for_()
            elif tmp_ == "from":
                return import_(True)
            elif tmp_ == "import":
                return import_(False)
            elif tmp_ == "class":
                BASELIB["extends"] = True
                if options.auto_bind:
                    BASELIB["rebind_all"] = True
                    BASELIB["bind"] = True  # used by rebind_all
                return class_()
            elif tmp_ == "def":
                start = prev()
                func = function_(S.in_scope[-1].type == "class" ? S.in_scope[-1].name : False)
                func.start = start
                func.end = prev()
                chain = subscripts(func, True)
                if chain == func:
                    return func
                else:
                    return new AST_SimpleStatement({
                        start: start,
                        body: chain,
                        end: prev()
                    })
            elif tmp_ == "if":
                return if_()
            elif tmp_ == "pass":
                semicolon()
                return new AST_EmptyStatement()
            elif tmp_ == "return" or tmp_ == "yield":
                if S.in_scope[-1].type != "function":
                    croak("'return' outside of function")

                if tmp_ == "yield":
                    S.in_scope[-1].generator = True
                    ctor = AST_Yield
                else:
                    ctor = AST_Return

                return new ctor({
                    value: (is_("punc", ";") ?
                        (def():
                            semicolon()
                            return None
                        )() : (can_insert_semicolon() ? None
                            : (def():
                                tmp = expression(True)
                                semicolon()
                                return tmp
                            )()
                        )
                    )
                })
            elif tmp_ == "switch":
                return new AST_Switch({
                    expression: parenthesised(),
                    body: in_loop(switch_body_)
                })
            elif tmp_ == "raise":
                if S.token.nlb:
                    return new AST_Throw({
                        value: new AST_SymbolCatch({
                            name: "ՐՏ_Exception"
                        })
                    })

                tmp = expression(True)
                semicolon()
                return new AST_Throw({
                    value: tmp
                })
            elif tmp_ == "try":
                return try_()
            elif tmp_ == "nonlocal":
                tmp = nonlocal_()
                semicolon()
                return tmp
            elif tmp_ == "const":
                tmp = const_()
                semicolon()
                return tmp
            elif tmp_ == "with":
                return new AST_With({
                    expression: parenthesised(),
                    body: statement()
                })
            else:
                unexpected()
    )

    def labeled_statement():
        label = as_symbol(AST_Label)
        if find_if(def(l):
            return l.name == label.name
        , S.labels):
            # ECMA-262, 12.12: An ECMAScript program is considered
            # syntactically incorrect if it contains a
            # LabelledStatement that is enclosed by a
            # LabelledStatement with the same Identifier as label.
            croak("Label " + label.name + " defined twice")

        expect(":")
        S.labels.push(label)
        stat = statement()
        S.labels.pop()
        return new AST_LabeledStatement({
            body: stat,
            label: label
        })

    def simple_statement(tmp):
        tmp = expression(True)
        semicolon()
        return new AST_SimpleStatement({
            body: tmp
        })

    def break_cont(type):
        label = None
        if not can_insert_semicolon():
            label = as_symbol(AST_LabelRef, True)

        if label != None:
            if not find_if(def(l):
                return l.name == label.name
            , S.labels):
                croak("Undefined label " + label.name)

        elif S.in_loop == 0:
            croak(type.TYPE + " not inside a loop or switch")

        semicolon()
        return new type({
            label: label
        })

    def seq_to_array(seq):
        # convert AST_Seq into AST_Array
        tmp = []
        iter = seq
        while iter and iter.car:
            tmp.push(iter.car)
            iter = iter.cdr
        tmp.push(iter)

        return new AST_Array({
            start: seq.start,
            elements: tmp,
            end: seq.end
        })

    def for_(list_comp):
        #        expect("(");
        init = None
        if not is_("punc", ";"):
            init = expression(True, True)
            # standardize AST_Seq into array now for consistency
            if isinstance(init, AST_Seq):
                init = seq_to_array(init)

            if is_("operator", "in"):
                if isinstance(init, AST_Var) and init.definitions.length > 1:
                    croak("Only one variable declaration allowed in for..in loop")
                next()
                return for_in(init, list_comp)

        unexpected()

    def for_in(init, list_comp):
        lhs = isinstance(init, AST_Var) ? init.definitions[0].name : None
        obj = expression(True)

        # mark iterator variable as local
        if isinstance(init, AST_Array):
            for element in init.elements:
                mark_local_assignment(element)
        else:
            mark_local_assignment(init)

        BASELIB["iterable"] = True
        if list_comp:
            return {
                init: init,
                name: lhs,
                object: obj
            }

        return new AST_ForIn({
            init: init,
            name: lhs,
            object: obj,
            body: in_loop(statement)
        })

    # A native JavaScript for loop - for JS("var i=0; i<5000; i++"):
    def for_js():
        condition = expression(True, True)
        return new AST_ForJS({
            condition: condition,
            body: in_loop(statement)
        })

    # scan function/class body for nested class declarations
    def get_class_in_scope(expr):
        # TODO: Currently if a local variable shadows a class name defined in
        # an outerscope, the logic below will identify that variable as a
        # class. This bug was always present. Fixing it will require the parser
        # to maintain a list of local variables for every AST_Scope and provide
        # an easy way to walk the ast tree upwards.
        if isinstance(expr, AST_SymbolRef):
            # check Native JS classes
            if NATIVE_CLASSES.hasOwnProperty(expr.name):
                return NATIVE_CLASSES[expr.name]

            # traverse in reverse to check local variables first
            for s in range(S.in_scope.length-1, -1, -1):
                if S.in_scope[s].classes.hasOwnProperty(expr.name):
                    return S.in_scope[s].classes[expr.name]

        elif isinstance(expr, AST_Dot):
            referenced_path = []
            # this one is for detecting classes inside modules and eventually nested classes
            while isinstance(expr, AST_Dot):
                referenced_path.unshift(expr.property)
                expr = expr.expression
            if isinstance(expr, AST_SymbolRef):
                referenced_path.unshift(expr.name)
                # now 'referenced_path' should contain the full path of potential class
                if len(referenced_path) > 1:
                    class_name = referenced_path.join('.')
                    for s in range(S.in_scope.length-1, -1, -1):
                        if S.in_scope[s].classes.hasOwnProperty(class_name):
                            return S.in_scope[s].classes[class_name]
        return False

    def do_import(key):
        if IMPORTED.hasOwnProperty(key):
            return
        if IMPORTING.hasOwnProperty(key) and IMPORTING[key]:
            raise ImportError('Detected a recursive import of: ' + key + ' while importing: ' + module_id)

        # Ensure that the package containing this module is also imported
        package_module_id = key.split('.')[:-1].join('.')
        if len(package_module_id) > 0:
            do_import(package_module_id)

        def safe_read(base_path):
            for i, path in enumerate([base_path + '.pyj', base_path + '/__init__.pyj']):
                try:
                    return [options.readfile(path, "utf-8"), path]
                except as e:
                    if e.code == 'ENOENT' or e.code == 'EPERM' or e.code == 'EACCESS':
                        if i == 1:
                            return None, None
                    if i == 1:
                        raise

        src_code = filename = None
        modpath = key.replace('.', '/')

        for location in import_dirs:
            if location:
                data, filename = safe_read(location + '/' + modpath)
                if data is not None:
                    src_code = data
                    break
        if src_code is None:
            raise "Failed Import: '" + key + "' module doesn't exist in any of the import directories: " + import_dirs.join(', ')
        contents = parse(src_code, {
                filename: filename,
                toplevel: None,
                readfile: options.readfile,
                basedir: options.basedir,
                libdir: options.libdir,
                module_id: key,
                IMPORTED: IMPORTED,
                IMPORTING: IMPORTING,
        })
        if len(package_module_id) > 0:
            IMPORTED[package_module_id].submodules.push(key)


    import_ = def(from_import):
        ans = new AST_Imports({'imports':[]})
        while True:
            tmp = name = expression(False)
            key = ''
            while isinstance(tmp, AST_Dot):
                key = "." + tmp.property + key
                tmp = tmp.expression
            key = tmp.name + key
            alias = None
            if not from_import and is_('keyword', 'as'):
                next()
                alias = as_symbol(AST_SymbolAlias)
            imp = new AST_Import({
                'module': name,
                'key': key,
                'alias': alias,
                'argnames':None,
                'body':def():
                    return IMPORTED[key]
            })
            ans.imports.push(imp)
            if from_import:
                break
            if is_('punc', ','):
                next()
            else:
                break

        for imp in ans['imports']:
            do_import(imp.key)
            classes = IMPORTED[key].classes
            if from_import:
                expect_token("keyword", "import")
                imp.argnames = argnames = []
                while True:
                    aname = as_symbol(AST_ImportedVar)
                    if from_import and name.name == 'danger_zone' and aname.name == 'equality':
                        DANGER_ZONE[options.module_id].equality = True
                        BASELIB["eq"] = True
                    if is_('keyword', 'as'):
                        next()
                        aname.alias = as_symbol(AST_SymbolAlias)
                    argnames.push(aname)
                    if is_('punc', ','):
                        next()
                    else:
                        break

                # Put imported class names in the outermost scope
                for argvar in argnames:
                    obj = classes[argvar.name]
                    if obj:
                        key = (argvar.alias) ? argvar.alias.name : argvar.name
                        S.in_scope[-1].classes[key] = { "static": obj.static, "bound": obj.bound }
            else:
                for i in dir(classes):
                    obj = classes[i]
                    if isinstance(obj, AST_Class):
                        key = (imp.alias) ? imp.alias.name : imp.key
                        S.in_scope[-1].classes[key + '.' + obj.name.name] = { "static": obj.static, "bound": obj.bound }

        return ans


    class_ = def():
        name = as_symbol(AST_SymbolDefun)
        if not name:
            unexpected()

        # detect external classes
        externaldecorator = S.decorators.indexOf("external")
        if externaldecorator != -1:
            S.decorators.splice(externaldecorator, 1)

        class_details = {
            "static": [],
            "bound": {}
        }

        # class setup
        definition = new AST_Class({
            name: name,
            module_id:module_id,
            parent: (def():
                if is_("punc", "("):
                    next()
                    if is_('punc', ')'):
                        S.in_parenthesized_expr = False
                        next()
                        return None
                    a = expr_atom(False)
                    expect(")")
                    return a
                else:
                    return None
            )(),
            localvars: [],
            static: class_details.static,
            external: externaldecorator != -1,
            bound: class_details.bound,
            statements: [],
            decorators: (def():
                d = []
                S.decorators.forEach(def(decorator):
                    if decorator == 'kwargs':
                        BASELIB['kwargs'] = True
                    d.push(new AST_Decorator({
                        name: decorator
                    }))
                )
                S.decorators = []
                return d
            )(),
            body: (def(loop, labels):
                # navigate to correct location in the module tree and append the class

                # state "push"
                S.in_scope[-1].classes[name.name] = class_details
                S.in_scope.push({
                    type: "class",
                    name: name.name,
                    nonlocal: {},
                    vars: {},
                    classes: {}
                })
                S.in_directives = True
                S.in_loop = 0
                S.labels = []

                a = block_()

                # state "pop"
                S.in_scope.pop()
                S.in_loop = loop
                S.labels = labels

                return a
            )(S.in_loop, S.labels)
        })

        # find the constructor
        for i in dir(definition.body):
            stmt = definition.body[i]
            if isinstance(stmt, AST_Method) and stmt.name.name == "__init__":
                definition.init = stmt
                break

        # find class variables
        class_var_names = {}
        # Ensure that if a class variable refers to another class variable in
        # its initialization, the referenced variables' names are correctly
        # mangled.
        def walker():
            this._visit = def(node, descend):
                if isinstance(node, AST_Method):
                    class_var_names[node.name.name] = True
                    return
                elif isinstance(node, AST_Assign) and isinstance(node.left, AST_SymbolRef):
                    class_var_names[node.left.name] = True

                for child in node:
                    if isinstance(node[child], AST_SymbolRef) and Object.prototype.hasOwnProperty.call(class_var_names, node[child].name):
                        node[child] = new AST_SymbolClassRef({
                            'class': name,
                            'name': node[child].name
                        })
                if descend:
                    descend.call(node)
        visitor = new walker()

        for stmt in definition.body:
            if not isinstance(stmt, AST_Class) and not isinstance(stmt, AST_Method):
                stmt.walk(visitor)
                definition.statements.push(stmt)

        if S.in_scope.length == 1:  # we're in top level
            CLASS_MAP[definition.name.name] = definition

        return definition

    function_ = def(in_class, ctor):
        is_accessor = ctor is AST_Accessor
        name = (is_("name") ? as_symbol((in_class ? AST_SymbolDefun : (is_accessor ? AST_SymbolAccessor : AST_SymbolLambda))) : (is_accessor and (is_("string") or is_("num")) ? as_atom_node() : None))
        if in_class and not name:
            unexpected()

        generator = False
        localvars = None
        staticmethod = False
        # special decorators are decorators that have special meaning to the compiler
        has_special_decorator = def(name):
            index = S.decorators.indexOf(name)
            if index != -1:
                S.decorators.splice(index, 1)
                return True
            return False

        if in_class:
            if has_special_decorator("staticmethod"):
                S.in_scope[-2].classes[in_class].static.push(name.name)
                staticmethod = True
            if has_special_decorator("bind") or name.name != "__init__" and options.auto_bind:
                BASELIB["bind"] = True
                S.in_scope[-2].classes[in_class].bound[name.name] = True

        expect("(")
        if not ctor:
            ctor = in_class ? AST_Method : AST_Function

        return new ctor({
            name: name,
            argnames: (def(a):
                defaults = {}
                first = True
                seen_names = {}

                def get_arg():
                    if Object.prototype.hasOwnProperty.call(seen_names, S.token.value):
                        token_error(prev(), "Can't repeat parameter names")
                    if S.token.value == 'arguments':
                        token_error(prev(), "Can't use the name arguments as a parameter name, it is reserved by JavaScript")
                    seen_names[S.token.value] = True
                    return as_symbol(AST_SymbolFunarg)

                while not is_("punc", ")"):
                    if first:
                        first = False
                    else:
                        expect(",")
                    if is_('operator', '**'):

                        # FIXME: temporary assertion while I get the logic tested and out the door
                        token_error(prev(), "**kwargs in function definition is not implemented yet, work in progress")

                        # **kwargs
                        next()
                        if a.kwargs:
                            token_error(prev(), "Can't define multiple **kwargs in function definition")
                        a.kwargs = get_arg()
                    elif is_('operator', '*'):
                        # *args
                        next()
                        if a.starargs:
                            token_error(prev(), "Can't define multiple *args in function definition")
                        if a.kwargs:
                            token_error(prev(), "Can't define *args after **kwargs in function definition")
                        a.starargs = get_arg()
                    else:
                        if a.starargs or a.kwargs:
                            token_error(prev(), "Can't define a formal parameter after *args or **kwargs")
                        a.push(get_arg())
                        if is_("operator", "="):
                            if a.kwargs:
                                token_error(prev(), "Can't define an optional formal parameter after **kwargs")
                            val = prev().value
                            next()
                            defaults[val] = expression(False)
                            a.has_defaults = True
                        else:
                            if a.has_defaults:
                                token_error(prev(), "Can't define required formal parameters after optional formal parameters")

                next()
                a.defaults = defaults
                return a
            )([]),
            decorators: (def():
                d = []
                S.decorators.forEach(def(decorator):
                    d.push(new AST_Decorator({
                        name: decorator
                    }))
                )
                S.decorators = []
                return d
            )(),
            body: (def(loop, labels):
                # parse function content

                # state "push"
                S.in_scope.push({
                    type: "function",
                    nonlocal: {},
                    vars: { "ՐՏ_Temp": ["?"] }, # a temporary workaround to avoid strict mode from going berserk, we'll assume there is a temp var in each scope
                    args: {},
                    classes: {}
                })
                S.in_directives = True
                S.in_loop = 0
                S.labels = []

                a = block_()

                # these transform variables that are used by other keys, hence the somewhat ugly use of nonlocal
                nonlocal generator, localvars
                generator = S.in_scope[-1].generator
                localvars = Object.keys(S.in_scope[-1].vars).filter(def(variable):
                    if variable in S.in_scope[-1].nonlocal: return False
                    return True
                ).map(def(variable):
                    return new_symbol(AST_SymbolVar, variable)
                )

                # state "pop"
                S.in_scope.pop()
                S.in_loop = loop
                S.labels = labels

                return a
            )(S.in_loop, S.labels),
            generator: generator,
            localvars: localvars,
            static: in_class and staticmethod
        })

    def if_():
        cond = expression(True)
        body = statement()
        belse = None
        if is_("keyword", "elif") or is_("keyword", "else"):
            if is_("keyword", "else"):
                next()
            else:
                S.token.value = "if"
            # effectively converts 'elif' to 'else if'
            belse = statement()

        return new AST_If({
            condition: cond,
            body: body,
            alternative: belse
        })

    def block_():
        expect(":")
        a = []
        if not S.token.nlb:
            while not S.token.nlb:
                if is_("eof"):
                    unexpected()
                a.push(statement())
        else:
            while not is_("punc", "}"):
                if is_("eof"):
                    # end of file, terminate block automatically
                    return a
                a.push(statement())
            next()
        return a

    def switch_body_():
        expect("{")
        a = []
        cur = None
        branch = None

        while not is_("punc", "}"):
            if is_("eof"):
                unexpected()

            if is_("keyword", "case"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Case({
                    start: (def():
                        tmp = S.token
                        next()
                        return tmp
                    )(),
                    expression: expression(True),
                    body: cur
                })
                a.push(branch)
                expect(":")
            elif is_("keyword", "default"):
                if branch:
                    branch.end = prev()

                cur = []
                branch = new AST_Default({
                    start: (def():
                        tmp = S.token
                        next()
                        expect(":")
                        return tmp
                    )(),
                    body: cur
                })
                a.push(branch)
            else:
                if not cur:
                    unexpected()
                cur.push(statement())

        if branch:
            branch.end = prev()
        next()
        return a

    def try_():
        body = block_()
        bcatch = []
        bfinally = None
        while is_("keyword", "except"):
            start = S.token
            next()
            exceptions = []
            if not is_("punc", ":") and not is_("keyword", "as"):
                exceptions.push(as_symbol(AST_SymbolVar))
                while is_("punc", ","):
                    next()
                    exceptions.push(as_symbol(AST_SymbolVar))

            name = None
            if is_("keyword", "as"):
                next()
                name = as_symbol(AST_SymbolCatch)

            bcatch.push(new AST_Except({
                start: start,
                argname: name,
                errors: exceptions,
                body: block_(),
                end: prev()
            }))

        if is_("keyword", "finally"):
            start = S.token
            next()
            bfinally = new AST_Finally({
                start: start,
                body: block_(),
                end: prev()
            })

        if not bcatch.length and not bfinally:
            croak("Missing except/finally blocks")

        return new AST_Try({
            body: body,
            bcatch: (bcatch.length ? new AST_Catch({
                body: bcatch
            }) : None),
            bfinally: bfinally
        })

    def vardefs(no_in, type):
        a = []
        while True:
            a.push(new AST_VarDef({
                start: S.token,
                name: as_symbol(type == "const" ? AST_SymbolConst : AST_SymbolVar),
                value: (is_("operator", "=") ? (next(), expression(False, no_in)) : None),
                end: prev()
            }))
            if type == "nonlocal": S.in_scope[-1].nonlocal[a[-1].name.name] = True
            if not is_("punc", ","):
                break
            next()

        return a

    nonlocal_ = def(no_in):
        return new AST_Var({
            start: prev(),
            definitions: vardefs(no_in, "nonlocal"),
            end: prev()
        })

    const_ = def():
        return new AST_Const({
            start: prev(),
            definitions: vardefs(False, "const"),
            end: prev()
        })

    new_ = def():
        start = S.token
        expect_token("operator", "new")
        newexp = expr_atom(False)

        if is_("punc", "("):
            next()
            args = expr_list(")")
        else:
            args = []

        return subscripts(new AST_New({
            start: start,
            expression: newexp,
            args: args,
            end: prev()
        }), True)

    def as_atom_node(token):
        tok = token or S.token
        tmp_ = tok.type
        if tmp_ == "name":
            ret = as_symbol(AST_SymbolRef, token=tok)
        elif tmp_ == "num":
            ret = new AST_Number({
                start: tok,
                end: tok,
                value: tok.value
            })
        elif tmp_ == "string":
            ret = new AST_String({
                start: tok,
                end: tok,
                value: tok.value,
                modifier: tok.subtype
            })
        elif tmp_ == "regexp":
            ret = new AST_RegExp({
                start: tok,
                end: tok,
                value: tok.value
            })
        elif tmp_ == "atom":
            tmp__ = tok.value
            if tmp__ == "False":
                ret = new AST_False({
                    start: tok,
                    end: tok
                })
            elif tmp__ == "True":
                ret = new AST_True({
                    start: tok,
                    end: tok
                })
            elif tmp__ == "None":
                ret = new AST_Null({
                    start: tok,
                    end: tok
                })

        if not token:
            next()
        return ret

    expr_atom = def(allow_calls):
        if is_("operator", "new"):
            return new_()

        start = S.token
        if is_("punc"):
            tmp_ = start.value
            if tmp_ == "(":
                next()
                ex = expression(True)
                ex.start = start
                ex.end = S.token
                if isinstance(ex, AST_SymbolRef):
                    ex.parens = True
                expect(")")
                return subscripts(ex, allow_calls)
            elif tmp_ == "[":
                return subscripts(array_(), allow_calls)
            elif tmp_ == "{":
                return subscripts(object_(), allow_calls)

            unexpected()

        if is_("keyword", "class"):
            next()
            cls = class_()
            cls.start = start
            cls.end = prev()
            return subscripts(cls, allow_calls)

        if is_("keyword", "def"):
            next()
            func = function_(False)
            func.start = start
            func.end = prev()
            return subscripts(func, allow_calls)

        if ATOMIC_START_TOKEN[S.token.type]:
            return subscripts(as_atom_node(), allow_calls)

        unexpected()

    def expr_list(closing, allow_trailing_comma, allow_empty, func_call):
        first = True
        a = []
        saw_starargs = False
        while not is_("punc", closing):
            if saw_starargs:
                token_error(prev(), "*args must be the last argument in a function call")

            if first:
                first = False
            else:
                expect(",")
            if allow_trailing_comma and is_("punc", closing):
                break

            if is_("operator", "*") and func_call:
                saw_starargs = True
                next()

            if is_("punc", ",") and allow_empty:
                a.push(new AST_Hole({
                    start: S.token,
                    end: S.token
                }))
            else:
                a.push(expression(False))

        if func_call:
            tmp = []
            tmp.kwargs = []
            for i, arg in enumerate(a):
                if isinstance(arg, AST_Assign):
                    # arg=val
                    BASELIB['kwargs'] = True
                    tmp.kwargs.push([arg.left, arg.right])
                else:
                    # regular argument
                    tmp.push(arg)
            a = tmp

        next()
        if saw_starargs:
            a.starargs = True
        return a

    def func_call_list():
        a = []
        first = True
        a.kwargs = []
        a.kwarg_items = kwargs = []
        a.starargs = False
        while not is_("punc", ')'):
            if first:
                first = False
            else:
                expect(",")
            if is_('operator', '*'):
                # starargs argument
                next()
                arg = expression(False)
                arg.is_array = True
                a.push(arg)
                a.starargs = True
            elif is_('operator', '**'):
                # kwargs argument
                BASELIB['kwargs'] = True
                next()
                kwargs.push(as_symbol(AST_SymbolVar, False))
            else:
                # arg=val assignment
                arg = expression(False)
                if isinstance(arg, AST_Assign):
                    BASELIB['kwargs'] = True
                    a.kwargs.push([arg.left, arg.right])
                else:
                    a.push(arg)
        next()
        return a

    def read_comprehension(object):
        # shared by list and dict comprehensions
        terminator = isinstance(object, AST_DictComprehension) ? '}' : ']'
        expect_token('keyword', 'for')
        forloop = for_(True)
        BASELIB["iterable"] = True
        object.init = forloop.init
        object.name = forloop.name
        object.object = forloop.object
        object.condition = is_("punc", terminator) ? None : (expect_token("keyword", "if"), expression(True))
        expect(terminator)
        return object

    array_ = embed_tokens(def():
        expect("[")
        expr = []
        if not is_("punc", "]"):
            expr.push(expression(False))
            if is_("keyword", "for"):
                # list comprehension
                return read_comprehension(new AST_ListComprehension({ statement: expr[0] }))

            if is_("operator", "til"):
                # up to but not including upper limit
                BASELIB['range'] = True
                next()
                expr.push(expression(False))
                ret = subscripts(new AST_Call({
                    start: S.token,
                    expression: new AST_SymbolRef({
                        name: "range"
                    }),
                    args: expr,
                    end: prev()
                }), True)
                expect("]")
                return ret
            elif is_("operator", "to"):
                # now add a tiny number to make sure we include the upper limit
                BASELIB['range'] = True
                next()
                expr.push(new AST_Binary({
                    left: expression(False),
                    operator: "+",
                    right: new AST_Number({
                        value: 0.000001
                    })
                }))
                ret = subscripts(new AST_Call({
                    start: S.token,
                    expression: new AST_SymbolRef({
                        name: "range"
                    }),
                    args: expr,
                    end: prev()
                }), True)
                expect("]")
                return ret
            elif not is_("punc", "]"):
                expect(",")

        return new AST_Array({
            elements: expr.concat(expr_list("]", not options.strict, True))
        })
    )
    object_ = embed_tokens(def():
        maybe_dict_comprehension = False
        expect("{")
        first = True
        a = []
        while not is_("punc", "}"):
            if not first:
                expect(",")
            if not options.strict and is_("punc", "}"):
                # allow trailing comma
                break

            start = S.token
            type = start.type
            if first and peek().value != ':':
                # possibly dict comprehension
                maybe_dict_comprehension = True
                key = expression(False)
                name = None
            else:
                key = as_property_name()
                name = key.value
                quoted = key.type == "string"

            if type == "name" and not is_("punc", ":"):
                if name == "get":
                    a.push(new AST_ObjectGetter({
                        start: start,
                        key: name,
                        quoted: quoted,
                        value: function_(False, AST_Accessor),
                        end: prev()
                    }))
                    continue

                if name == "set":
                    a.push(new AST_ObjectSetter({
                        start: start,
                        key: name,
                        quoted: quoted,
                        value: function_(False, AST_Accessor),
                        end: prev()
                    }))
                    continue

            expect(":")

            a.push(new AST_ObjectKeyVal({
                start: start,
                key: name,
                quoted: quoted,
                value: expression(False),
                end: prev()
            }))

            if a.length == 1 and is_('keyword', 'for'):
                return read_comprehension(new AST_DictComprehension({
                    statement: maybe_dict_comprehension ? key : as_atom_node(a[0].start),
                    value_statement: a[0].value
                }))

            first = False

        next()
        return new AST_Object({
            properties: a
        })
    )

    def as_property_name():
        tmp = S.token
        next()
        tmp_ = tmp.type
        if tmp_ == "num" or tmp_ == "string" or tmp_ == "name" or tmp_ == "operator" or tmp_ == "keyword" or tmp_ == "atom":
            return tmp
        else:
            unexpected()

    def as_name():
        tmp = S.token
        next()
        tmp_ = tmp.type
        if tmp_ == "name" or tmp_ == "operator" or tmp_ == "keyword" or tmp_ == "atom":
            return tmp.value
        else:
            unexpected()

    def as_symbol(type, noerror, token):
        token_ = token or S.token
        if not is_token(token_, "name"):
            if not noerror:
                croak("Name expected")
            return None

        name = token_.value
        sym = new (name == "this" ? AST_This : type)({
            name: (String)(token_.value),
            start: token_,
            end: token_
        })
        if not token:
            next()
        return sym

    # for generating/inserting a new symbol
    def new_symbol(type, name):
        sym = new ((name == "this" ? AST_This : type))({
            name: (String)(name),
            start: None,
            end: None
        })
        return sym

    def is_static_method(cls, method):
        if method in COMMON_STATIC or cls.static and method in cls.static:
            return True
        else:
            return False

    def mark_local_assignment(element):
        name = typeof element is "string" ? element : element.name
        if name:
            # not enough information to infer type yet
            # so all types are ? for now, in the future this function will infer type from context
            # that may need some refactoring of car/cdr logic
            if name in S.in_scope[-1].vars:
                S.in_scope[-1].vars[name].push("?")
            else:
                S.in_scope[-1].vars[name] = ["?"]

    subscripts = def(expr, allow_calls):
        start = expr.start
        if is_("punc", "."):
            next()
            return subscripts(new AST_Dot({
                start: start,
                expression: expr,
                property: as_name(),
                end: prev()
            }), allow_calls)

        if is_("punc", "[") and not S.token.nlb:
            next()
            slice_bounds = []
            is_slice = False
            if is_("punc", ":"):
                # slice [:n]
                slice_bounds.push(None)
            else:
                # slice [n?]
                slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m?]
                is_slice = True
                next()
                if is_("punc", ":"):
                    slice_bounds.push(None)
                elif not is_("punc", "]"):
                    slice_bounds.push(expression(False))

            if is_("punc", ":"):
                # slice [n:m:o?]
                BASELIB["eslice"] = True
                next()
                if is_("punc", "]"):
                    unexpected()
                else:
                    slice_bounds.push(expression(False))

            expect("]")

            if is_slice:
                if is_("operator") and S.token.value == "=":
                    # splice-assignment (arr[start:end] = ...)
                    next()  # swallow the assignment
                    return subscripts(new AST_Splice({
                        start: start,
                        expression: expr,
                        property: slice_bounds[0] or new AST_Number({
                            value: 0
                        }),
                        property2: slice_bounds[1],
                        assignment: expression(True),
                        end: prev()
                    }), allow_calls)
                elif slice_bounds.length == 3:
                    # extended slice (arr[start:end:step])
                    slice_bounds.unshift(slice_bounds.pop())
                    if not slice_bounds[-1]:
                        slice_bounds.pop()
                        if not slice_bounds[-1]:
                            slice_bounds.pop()
                    elif not slice_bounds[-2]:
                        slice_bounds[-2] = new AST_Undefined()

                    return subscripts(new AST_Call({
                        start: start,
                        expression: new AST_SymbolRef({
                            name: "eslice"
                        }),
                        args: [expr].concat(slice_bounds),
                        end: prev()
                    }), allow_calls)
                else:
                    # regular slice (arr[start:end])
                    slice_bounds = [i == None ? new AST_Number({
                        value: 0
                    }) : i for i in slice_bounds]
                    return subscripts(new AST_Call({
                        start: start,
                        expression: new AST_Dot({
                            start: start,
                            expression: expr,
                            property: "slice",
                            end: prev()
                        }),
                        args: slice_bounds,
                        end: prev()
                    }), allow_calls)
            else:
                # regular index (arr[index])
                return subscripts(new AST_Sub({
                    start: start,
                    expression: expr,
                    property: slice_bounds[0] or new AST_Number({
                        value: 0
                    }),
                    end: prev()
                }), allow_calls)

        if allow_calls and is_("punc", "(") and not S.token.nlb:
            next()
            if isinstance(expr, AST_SymbolRef) and expr.name == "JS":
                # raw JavaScript chunk of code
                str_ = expression(False)
                if not (isinstance(str_, AST_String)):
                    token_error(prev(), "Compile-time function JS() can't evaluate variables or expressions")

                ret = new AST_Verbatim({
                    start: start,
                    value: str_.value,
                    end: prev()
                })
                expect(")")
                return subscripts(ret, True)
            elif not expr.parens and get_class_in_scope(expr):
                # this is an object being created using a class

                # check if this class is part of our standard library
                if expr.name in STDLIB:
                    BASELIB[expr.name] = True
                    if /Error$/.test(expr.name):
                        # errors are classes
                        BASELIB["extends"] = True

                return subscripts(new AST_New({
                    start: start,
                    expression: expr,
                    args: func_call_list(),
                    end: prev()
                }), True)
            else:
                if isinstance(expr, AST_Dot):
                    c = get_class_in_scope(expr.expression)

                if c:
                    # generate class call
                    funcname = expr
                    if funcname.property == "__init__":
                        funcname.property = "constructor"

                    return subscripts(new AST_ClassCall({
                        start: start,
                        "class": expr.expression,
                        method: funcname.property,
                        "static": is_static_method(c, funcname.property),
                        args: func_call_list(),
                        end: prev()
                    }), True)
                elif isinstance(expr, AST_SymbolRef):
                    tmp_ = expr.name
                    # special functions that trigger addition of extra logic to generated JavaScript
                    if tmp_ in STDLIB:
                        BASELIB[tmp_] = True
                        # NOTE: there is intentionally no return here, we want these functions to go through regular logic
                        # after they trigger the appropriate baselib flag
                    elif tmp_ == "type":
                        return new AST_UnaryPrefix({
                            start: start,
                            operator: "typeof",
                            expression: func_call_list()[0],
                            end: prev()
                        })
                    elif tmp_ == "isinstance":
                        args = func_call_list()
                        return new AST_Binary({
                            start: start,
                            operator: "instanceof",
                            left: args[0],
                            right: args[1],
                            end: prev()
                        })

                # fall-through to basic function call
                return subscripts(new AST_Call({
                    start: start,
                    expression: expr,
                    args: func_call_list(),
                    end: prev()
                }), True)

        return expr

    maybe_unary = def(allow_calls):
        start = S.token
        if is_("operator") and UNARY_PREFIX(start.value):
            next()
            if start.value == "@":
                if is_("name") and (peek().value == "@" or peek().value == "def" or peek().value == "class"):
                    S.decorators.push(S.token.value)
                    next()
                    return new AST_EmptyStatement()
                else:
                    unexpected()

            ex = make_unary(AST_UnaryPrefix, start.value, maybe_unary(allow_calls))
            ex.start = start
            ex.end = prev()
            return ex

        val = expr_atom(allow_calls)
        while is_("operator") and UNARY_POSTFIX(S.token.value) and not S.token.nlb:
            val = make_unary(AST_UnaryPostfix, S.token.value, val)
            val.start = start
            val.end = S.token
            next()
        return val

    def make_unary(ctor, op, expr):
        return new ctor({
            operator: op,
            expression: expr
        })

    expr_op = def(left, min_prec, no_in):
        op = (is_("operator") ? S.token.value : None)
        not_in = False
        if op == "!" and peek().type == "operator" and peek().value == "in":
            next()
            op = "in"
            not_in = True

        if op == "in":
            if no_in:
                op = None
            else:
                BASELIB[op] = True

        prec = (op != None ? PRECEDENCE[op] : None)
        if prec != None and prec > min_prec:
            next()
            right = expr_op(maybe_unary(True), prec, no_in)
            if DANGER_ZONE[options.module_id].equality and op in ['==', '!=']:
                ret = new AST_DeepEquality({
                    start: left.start,
                    left: left,
                    operator: op,
                    right: right,
                    end: right.end
                })
            else:
                ret = new AST_Binary({
                    start: left.start,
                    left: left,
                    operator: op,
                    right: right,
                    end: right.end
                })
            if not_in:
                ret = new AST_UnaryPrefix({
                    start: left.start,
                    operator: "!",
                    expression: ret,
                    end: right.end
                })
            return expr_op(ret, min_prec, no_in)
        return left

    def expr_ops(no_in):
        return expr_op(maybe_unary(True), 0, no_in)

    maybe_conditional = def(no_in):
        start = S.token
        expr = expr_ops(no_in)
        if is_("operator", "?"):
            next()
            yes = expression(False)
            expect(":")
            return new AST_Conditional({
                start: start,
                condition: expr,
                consequent: yes,
                alternative: expression(False, no_in),
                end: peek()
            })
        return expr

    def is_assignable(expr):
        if not options.strict:
            return True

        tmp_ = expr[0] + ""
        if tmp_ == "dot" or tmp_ == "sub" or tmp_ == "new" or tmp_ == "call":
            return True
        elif tmp_ == "name":
            return expr[1] != "this"

    maybe_assign = def(no_in):
        start = S.token
        left = maybe_conditional(no_in)
        val = S.token.value
        if is_("operator") and ASSIGNMENT(val):
            if is_assignable(left):
                # regular assignment will be picked up here
                mark_local_assignment(left)
                # if left.name:   # this is a bit of a hack to check that the object is variable-like
                #     # if val != "=" and left.name not in S.in_scope[-1].vars and left.name not in S.in_scope[-1].nonlocal:
                #     #     croak("Attempting to increment/modify uninitialized variable '" + left.name + "', this can also occur if you're trying to shadow without initializing the variable in local scope.")
                #     S.in_scope[-1].vars[left.name] = ["?"]  # TODO: for now we don't care about the type, eventually we'll check it
                next()
                return new AST_Assign({
                    start: start,
                    left: left,
                    operator: val,
                    right: maybe_assign(no_in),
                    end: prev()
                })
            croak("Invalid assignment")
        return left

    expression = def(commas, no_in):
        # if there is an assignment, we want the sequences to pivot
        # around it to allow for tuple packing/unpacking
        start = S.token
        expr = maybe_assign(no_in)
        if commas:
            left = [ expr ]
            right = []
            while is_("punc", ",") and not peek().nlb:
                next()
                if isinstance(expr, AST_Assign):
                    # AST_Seq representation is ugly to decode for
                    # assignments, let's convert data to array now
                    # to avoid dealing with it
                    left[-1] = left[-1].left
                    if left.length == 1:
                        if isinstance(left[0], AST_Seq):
                            # convert sequence to array and add every variable to local scope
                            leftAst = seq_to_array(left[0])
                            for element in leftAst:
                                mark_local_assignment(element)
                        else:
                            # not sure if we'd ever end up here, except maybe if user left a stray comma
                            leftAst = left[0]
                            mark_local_assignment(leftAst)
                    else:
                        # explicit array
                        leftAst = new AST_Array({
                            elements: left
                        })
                        for element in left:
                            mark_local_assignment(element)

                    return new AST_Assign({
                        start: start,
                        left: leftAst,
                        operator: expr.operator,
                        right: new AST_Seq({
                            car: expr.right,
                            cdr: expression(True, no_in)
                        }),
                        end: peek()
                    })

                expr = maybe_assign(no_in)
                left.push(expr)

            # transform assignments to (a, b, ...) into [a, b, ...]
            if isinstance(expr, AST_Assign) and isinstance(expr.left, AST_Seq):
                expr.left = seq_to_array(expr.left)

            # if last one was an assignment, fix it
            if left.length > 1 and isinstance(left[-1], AST_Assign):
                left[-1] = left[-1].left
                for element in left:
                    mark_local_assignment(element)
                return new AST_Assign({
                    start: start,
                    left: new AST_Array({
                        elements: left
                    }),
                    operator: expr.operator,
                    right: expr.right,
                    end: peek()
                })

            #recursive sequence formation
            return (def build_seq(a):
                if a.length == 1:
                    return a[0]

                return new AST_Seq({
                    start: start,
                    car: a.shift(),
                    cdr: build_seq(a),
                    end: peek()
                })
            )(left)

        return expr

    def in_loop(cont):
        S.in_loop += 1
        ret = cont()
        S.in_loop -= 1
        return ret

    return (def():
        start = S.token
        body = []
        first_token = True
        while not is_("eof"):
            element = statement()
            if first_token and isinstance(element, AST_Directive) and element.value.indexOf('#!') == 0:
                shebang = element.value
            else:
                body.push(element)
            first_token = False

        end = prev()
        toplevel = options.toplevel
        if toplevel:
            toplevel.body = toplevel.body.concat(body)
            toplevel.end = end
        else:
            toplevel = new AST_Toplevel({
                start: start,
                body: body,
                strict: (def():
                    for stmt in body:
                        if isinstance(stmt, AST_Directive) and stmt.value == 'use strict':
                            return True
                    return False
                )(),
                shebang: shebang,
                end: end
            })

        def uniq(element, index, arr):
            return arr.lastIndexOf(element) == index

        toplevel.nonlocalvars = Object.keys(S.in_scope[-1].nonlocal)
        assignments = Object.keys(S.in_scope[-1].vars)
        callables = scan_for_top_level_callables(toplevel.body).filter(uniq)
        toplevel.localvars = []
        assignments.forEach(def(item):
            if item not in toplevel.nonlocalvars:
                toplevel.localvars.push(new_symbol(AST_SymbolVar, item))
        )
        toplevel.exports = toplevel.localvars.concat(callables).filter(uniq)
        toplevel.submodules = []
        toplevel.classes = CLASS_MAP
        toplevel.import_order = Object.keys(IMPORTED).length
        toplevel.module_id = module_id
        IMPORTED[module_id] = toplevel
        toplevel.imports = IMPORTED
        toplevel.baselib = BASELIB
        IMPORTING[module_id] = False
        return toplevel
    )()

