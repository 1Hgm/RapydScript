###########################################################
# RapydScript Standard Library
# Author: Alexander Tsepkov
# Copyright 2013 Pyjeon Software LLC
# License: Apache License    2.0
# This library is covered under Apache license, so that
# you can distribute it with your RapydScript applications.
###########################################################


###########################################################
# Basic Functionality
###########################################################

# Pythonic shortcut for converting an object to string
str = JSON.stringify

# WARNING: when using this function decorator, you will not be able to use obfuscators that rename local variables
def kwargs(f):
    argNames = f.toString().match(/\(([^\)]+)/)[1]
    argNames = argNames ? argNames.split(',').map(def(s): return s.trim();) : []
    return def():
        args = [].slice.call(arguments)
        if args.length:
            kw = args.pop()
            if type(kw) == 'object':
                for i in range(argNames.length):
                    if argNames[i] in dir(kw):
                        args[i] = kw[argNames[i]]
            else:
                args.push(kw)
        return f.apply(this, args)


###########################################################
# Errors
###########################################################
class IndexError(Error):
    def __init__(self, message="list index out of range"):
        self.name = "IndexError"
        self.message = message

class TypeError(Error):
    def __init__(self, message):
        self.name = "TypeError"
        self.message = message

class ValueError(Error):
    def __init__(self, message):
        self.name = "ValueError"
        self.message = message

class AssertionError(Error):
    def __init__(self, message=""):
        self.name = "AssertionError"
        self.message = message


###########################################################
# Arrays
###########################################################
def map(oper, arr):
	return list(arr.map(oper))

def filter(oper, arr):
	return list(arr.filter(oper))

def sum(arr, start=0):
    return arr.reduce(
        def(prev, cur): return prev+cur;,
        start
    )


###########################################################
# Deep Equality Comparison
###########################################################
def deep_eq(a, b):
    """
    Equality comparison that works with all data types, returns true if structure and
    contents of first object equal to those of second object

    Arguments:
        a: first object
        b: second object
    """
    if a is b:
        # simple object
        return True

    if (isinstance(a, Array) and isinstance(b, Array)) or (isinstance(a, Object) and isinstance(b, Object)):
        # if length ot type doesn't match, they can't be equal
        if a.constructor is not b.constructor or a.length is not b.length:
            return False

        # compare individual properties (order doesn't matter if it's a hash)
        for i in dict.keys(a):
            if b.hasOwnProperty(i):
                # recursively test equality of object children
                if not deep_eq(a[i], b[i]):
                    return False
            else:
                return False
        return True
    return False
